name: üîÑ Continuous Monitoring

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Minimal required permissions for the workflow
permissions:
  contents: read  # For checking out code
  packages: read  # For downloading dependencies
  actions: read   # For reading workflow data
  security-events: write  # For security scanning
  checks: write   # For creating check runs
  pull-requests: write  # For PR comments
  issues: write   # For creating issues

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.11'

jobs:
  health-check:
    name: üè• System Health Check
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v5
      
    - name: üêç Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: üì¶ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev,test]"
        pip install psutil schedule radon bandit safety
        
    - name: üîç Run Health Check
      id: health_check
      run: |
        python scripts/monitoring/continuous_monitor.py check
        
        # Store results
        if [ -f "data/metrics/latest_health.json" ]; then
          echo "HEALTH_DATA<<EOF" >> $GITHUB_OUTPUT
          cat data/metrics/latest_health.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        fi
        
    - name: üìä Parse Health Results
      id: parse_results
      run: |
        if [ -f "data/metrics/latest_health.json" ]; then
          # Extract key metrics
          HEALTH_STATUS=$(python -c "
          import json
          with open('data/metrics/latest_health.json') as f:
              data = json.load(f)
              print(data['overall_health'])
          ")
          
          HEALTH_SCORE=$(python -c "
          import json
          with open('data/metrics/latest_health.json') as f:
              data = json.load(f)
              print(f\"{data['score']:.1f}\")
          ")
          
          ALERT_COUNT=$(python -c "
          import json
          with open('data/metrics/latest_health.json') as f:
              data = json.load(f)
              print(len(data['alerts']))
          ")
          
          echo "health_status=$HEALTH_STATUS" >> $GITHUB_OUTPUT
          echo "health_score=$HEALTH_SCORE" >> $GITHUB_OUTPUT
          echo "alert_count=$ALERT_COUNT" >> $GITHUB_OUTPUT
        fi
        
    - name: üìà Upload Health Metrics
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: health-metrics-${{ github.run_id }}
        path: |
          data/metrics/
          data/logs/
          data/alerts/
        retention-days: 30
        
    - name: üö® Create Alert Issue
      if: steps.parse_results.outputs.health_status == 'CRITICAL'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read health data
          let healthData = {};
          try {
            healthData = JSON.parse(fs.readFileSync('data/metrics/latest_health.json', 'utf8'));
          } catch (error) {
            console.log('Could not read health data:', error);
            return;
          }
          
          // Create issue body
          const issueBody = `
          # üö® Critical System Health Alert
          
          **Health Status:** ${healthData.overall_health}  
          **Health Score:** ${healthData.score.toFixed(1)}/100  
          **Timestamp:** ${healthData.timestamp}
          
          ## üö® Active Alerts
          ${healthData.alerts.map(alert => `- ‚ùå ${alert}`).join('\n')}
          
          ## üí° Recommendations
          ${healthData.recommendations.map(rec => `- üîß ${rec}`).join('\n')}
          
          ## üìä System Metrics
          - **CPU Usage:** ${healthData.system_metrics.cpu_percent?.toFixed(1) || 'N/A'}%
          - **Memory Usage:** ${healthData.system_metrics.memory_percent?.toFixed(1) || 'N/A'}%
          - **Disk Usage:** ${healthData.system_metrics.disk_percent?.toFixed(1) || 'N/A'}%
          
          ## üß™ Quality Metrics
          - **Test Coverage:** ${healthData.quality_metrics.test_coverage?.toFixed(1) || 'N/A'}%
          - **Lint Score:** ${healthData.quality_metrics.lint_score?.toFixed(1) || 'N/A'}%
          - **Type Coverage:** ${healthData.quality_metrics.type_coverage?.toFixed(1) || 'N/A'}%
          
          ## üîí Security Metrics
          - **Security Score:** ${healthData.security_metrics.bandit_score?.toFixed(1) || 'N/A'}%
          - **Secrets Found:** ${healthData.security_metrics.secrets_found || 0}
          
          ---
          
          **Workflow:** ${{ github.workflow }}  
          **Run ID:** ${{ github.run_id }}  
          **Commit:** ${{ github.sha }}
          
          > This issue was automatically created by the Continuous Monitoring system.
          `;
          
          // Check if similar issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['critical-health-alert']
          });
          
          if (existingIssues.data.length === 0) {
            // Create new issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Critical System Health Alert - Score: ${healthData.score.toFixed(1)}/100`,
              body: issueBody,
              labels: ['critical-health-alert', 'monitoring', 'urgent']
            });
            
            console.log('Created critical health alert issue:', issue.data.number);
          } else {
            // Update existing issue
            const issue = existingIssues.data[0];
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## üîÑ Updated Health Status\n\n${issueBody}`
            });
            
            console.log('Updated existing critical health alert issue:', issue.number);
          }
          
    - name: ‚úÖ Update Status Badge
      if: always()
      run: |
        # Create status badge data
        HEALTH_STATUS="${{ steps.parse_results.outputs.health_status || 'UNKNOWN' }}"
        HEALTH_SCORE="${{ steps.parse_results.outputs.health_score || '0.0' }}"
        
        # Determine badge color
        if [ "$HEALTH_STATUS" = "HEALTHY" ]; then
          COLOR="brightgreen"
        elif [ "$HEALTH_STATUS" = "WARNING" ]; then
          COLOR="yellow"
        elif [ "$HEALTH_STATUS" = "CRITICAL" ]; then
          COLOR="red"
        else
          COLOR="lightgrey"
        fi
        
        # Create badge JSON
        mkdir -p data/badges
        cat > data/badges/health-status.json << EOF
        {
          "schemaVersion": 1,
          "label": "health",
          "message": "$HEALTH_STATUS ($HEALTH_SCORE/100)",
          "color": "$COLOR"
        }
        EOF
        
    - name: üìä Generate Health Report
      if: always()
      run: |
        # Generate markdown report
        python -c "
        import json
        import sys
        from datetime import datetime
        
        try:
            with open('data/metrics/latest_health.json') as f:
                data = json.load(f)
        except:
            print('No health data available')
            sys.exit(0)
        
        report = f'''# üè• System Health Report
        
        **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}  
        **Workflow:** ${{ github.workflow }}  
        **Run ID:** ${{ github.run_id }}
        
        ## üìä Overall Status
        
        | Metric | Value |
        |--------|-------|
        | **Health Status** | {data['overall_health']} |
        | **Health Score** | {data['score']:.1f}/100 |
        | **Active Alerts** | {len(data['alerts'])} |
        
        ## üíª System Metrics
        
        | Metric | Value |
        |--------|-------|
        | CPU Usage | {data['system_metrics'].get('cpu_percent', 'N/A')}% |
        | Memory Usage | {data['system_metrics'].get('memory_percent', 'N/A')}% |
        | Disk Usage | {data['system_metrics'].get('disk_percent', 'N/A')}% |
        | Python Version | {data['system_metrics'].get('python_version', 'N/A')} |
        
        ## üß™ Quality Metrics
        
        | Metric | Value |
        |--------|-------|
        | Test Coverage | {data['quality_metrics'].get('test_coverage', 'N/A')}% |
        | Lint Score | {data['quality_metrics'].get('lint_score', 'N/A')}% |
        | Type Coverage | {data['quality_metrics'].get('type_coverage', 'N/A')}% |
        | Complexity Score | {data['quality_metrics'].get('complexity_score', 'N/A')}% |
        | Documentation | {data['quality_metrics'].get('documentation_score', 'N/A')}% |
        
        ## ‚ö° Performance Metrics
        
        | Metric | Value |
        |--------|-------|
        | Import Time | {data['performance_metrics'].get('import_time_ms', 'N/A')}ms |
        | Memory Usage | {data['performance_metrics'].get('memory_profile', {}).get('rss_mb', 'N/A')}MB |
        
        ## üîí Security Metrics
        
        | Metric | Value |
        |--------|-------|
        | Security Score | {data['security_metrics'].get('bandit_score', 'N/A')}% |
        | Safety Score | {data['security_metrics'].get('safety_score', 'N/A')}% |
        | Secrets Found | {data['security_metrics'].get('secrets_found', 'N/A')} |
        '''
        
        if data['alerts']:
            report += f'''
        ## üö® Active Alerts
        
        {chr(10).join(f'- ‚ùå {alert}' for alert in data['alerts'])}
        '''
        
        if data['recommendations']:
            report += f'''
        ## üí° Recommendations
        
        {chr(10).join(f'- üîß {rec}' for rec in data['recommendations'])}
        '''
        
        with open('data/health-report.md', 'w') as f:
            f.write(report)
        
        print('Health report generated successfully')
        " 
        
    - name: üì§ Upload Health Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: health-report-${{ github.run_id }}
        path: data/health-report.md
        retention-days: 7

  quality-trends:
    name: üìà Quality Trends Analysis  
    runs-on: ubuntu-latest
    needs: health-check
    if: always()
    
    steps:
    - name: üì• Checkout Code
      uses: actions/checkout@v5
      
    - name: üìä Download Previous Health Metrics
      uses: actions/download-artifact@v5
      continue-on-error: true
      with:
        pattern: health-metrics-*
        path: historical-metrics/
        
    - name: üìà Analyze Quality Trends
      run: |
        python -c "
        import json
        import os
        from pathlib import Path
        from datetime import datetime
        
        # Collect all historical metrics
        metrics_history = []
        
        for metrics_dir in Path('historical-metrics').glob('health-metrics-*'):
            metrics_file = metrics_dir / 'data' / 'metrics' / 'latest_health.json'
            if metrics_file.exists():
                with open(metrics_file) as f:
                    try:
                        data = json.load(f)
                        metrics_history.append(data)
                    except:
                        continue
        
        if len(metrics_history) < 2:
            print('Not enough historical data for trend analysis')
            exit(0)
        
        # Sort by timestamp
        metrics_history.sort(key=lambda x: x['timestamp'])
        
        # Calculate trends
        latest = metrics_history[-1]
        previous = metrics_history[-2]
        
        score_trend = latest['score'] - previous['score']
        
        print(f'Score Trend: {score_trend:+.1f} points')
        print(f'Current Score: {latest[\"score\"]:.1f}/100')
        print(f'Previous Score: {previous[\"score\"]:.1f}/100')
        
        # Check for degradation
        if score_trend < -5:
            print('‚ö†Ô∏è Significant quality degradation detected!')
            with open(os.environ['GITHUB_ENV'], 'a') as f:
                f.write('QUALITY_DEGRADATION=true\n')
        "
        
    - name: üö® Alert on Quality Degradation
      if: env.QUALITY_DEGRADATION == 'true' && github.event_name != 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'üìâ Quality Degradation Alert',
            body: `
            ## ‚ö†Ô∏è Quality Degradation Detected
            
            The continuous monitoring system has detected a significant drop in code quality metrics.
            
            **Triggered by:** ${{ github.workflow }} (Run #${{ github.run_id }})  
            **Commit:** ${{ github.sha }}
            
            Please review recent changes and run quality checks.
            
            ### Next Steps:
            1. Review recent commits for quality issues
            2. Run full test suite: \`make test\`
            3. Check linting: \`make lint\`
            4. Review code coverage: \`make coverage\`
            
            This issue was automatically created by the monitoring system.
            `,
            labels: ['quality-degradation', 'monitoring']
          });

  notification:
    name: üì¢ Status Notification
    runs-on: ubuntu-latest
    needs: [health-check, quality-trends]
    if: always()
    
    steps:
    - name: üìä Determine Notification Status  
      id: check_health
      run: |
        # Default values
        HEALTH_STATUS="UNKNOWN"
        
        # Check if health-check job completed successfully
        if [[ "${{ needs.health-check.result }}" == "success" ]]; then
          # Try to get the health status from the job outputs
          if [[ -n "${{ fromJson(needs.health-check.outputs).health_status }}" ]]; then
            HEALTH_STATUS="${{ fromJson(needs.health-check.outputs).health_status }}"
          # Fallback to a default value if the output is not accessible
          else
            echo "Warning: Could not read health status from job outputs"
            HEALTH_STATUS="UNKNOWN"
          fi
        else
          echo "Warning: health-check job did not complete successfully"
          HEALTH_STATUS="UNKNOWN"
        fi
        
        # Set the output for subsequent steps
        echo "HEALTH_STATUS=$HEALTH_STATUS" >> $GITHUB_OUTPUT
        echo "Using health status: $HEALTH_STATUS"
        
        if [ "$HEALTH_STATUS" = "CRITICAL" ]; then
          echo "üö® Critical health status detected"
          echo "SEND_NOTIFICATION=true" >> $GITHUB_ENV
          echo "NOTIFICATION_LEVEL=critical" >> $GITHUB_ENV
        elif [ "$HEALTH_STATUS" = "WARNING" ]; then
          echo "‚ö†Ô∏è Warning health status detected"
          echo "SEND_NOTIFICATION=true" >> $GITHUB_ENV
          echo "NOTIFICATION_LEVEL=warning" >> $GITHUB_ENV
        else
          echo "‚úÖ System health is good"
          echo "SEND_NOTIFICATION=false" >> $GITHUB_ENV
        fi
        
    - name: üìß Send Notification
      if: steps.check_health.outputs.HEALTH_STATUS == 'CRITICAL' || steps.check_health.outputs.HEALTH_STATUS == 'WARNING'
      env:
        NOTIFICATION_LEVEL: ${{ steps.check_health.outputs.HEALTH_STATUS == 'CRITICAL' && 'critical' || 'warning' }}
      run: |
        echo "Sending $NOTIFICATION_LEVEL notification..."
        # TODO: Implement actual notification system (email, Slack, etc.)
        echo "Would send $NOTIFICATION_LEVEL notification"